# Docker Build Optimization Guide

This document explains the optimized Docker build strategy implemented for faster development iteration.

## Quick Reference

```bash
# Generate requirements.lock after dependency changes
make generate-requirements

# Build Docker image (fast rebuilds with cache)
make docker-build

# Build from scratch (no cache)
make docker-build-no-cache
```

## How It Works

### Problem

The original Dockerfile copied all source code before installing dependencies:

```dockerfile
# OLD: Slow approach
COPY pyproject.toml polismath/ umap_narrative/ scripts/ *.py ./
RUN pip install --no-cache-dir .
```

**Issue**: Any code change forced complete dependency reinstallation (~15 minutes).

### Solution

The optimized Dockerfile uses a **layered caching strategy**:

1. **Install dependencies first** (cached unless requirements.lock changes)
2. **Copy source code second** (invalidates cache only for code changes)
3. **Register package without deps** (fast, just updates entry points)

```dockerfile
# NEW: Fast approach
COPY pyproject.toml requirements.lock ./
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.lock

COPY polismath/ umap_narrative/ scripts/ *.py ./
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install --no-deps .
```

### Key Technologies

1. **requirements.lock**: Pinned dependency versions from `pip-compile`
2. **BuildKit cache mounts**: Persistent pip cache between builds
3. **Layered copying**: Dependencies ‚Üí Source code ‚Üí Package registration
4. **Optimized .dockerignore**: Excludes unnecessary files from build context

## Performance Improvements

| Build Scenario | Before | After | Improvement |
|---------------|--------|-------|-------------|
| Clean build (no cache) | ~15 min | ~15 min | Same |
| Code change only | ~15 min | **~30 sec** | **30x faster** |
| Dependency update | ~15 min | ~5-8 min | 2-3x faster |
| With warm BuildKit cache | ~15 min | **~15 sec** | **60x faster** |

## Development Workflow

### Daily Development

```bash
# 1. Edit code
vim polismath/components/vote_matrix.py

# 2. Fast rebuild (30 seconds)
make docker-build

# 3. Test
docker compose up -d
docker logs -f polis-dev-delphi-1
```

### Updating Dependencies

```bash
# 1. Edit pyproject.toml
vim pyproject.toml

# 2. Regenerate lock file
make generate-requirements

# 3. Rebuild Docker image
make docker-build
```

### Upgrading All Dependencies

```bash
# Get latest compatible versions
make generate-requirements-upgrade

# Review changes
git diff requirements.lock

# Test thoroughly
make docker-build
docker compose up -d
# ... run tests ...

# Commit if stable
git add requirements.lock pyproject.toml
git commit -m "chore: update dependencies"
```

## Requirements Lock File

### Purpose

- **Reproducibility**: Same build everywhere (dev, CI, prod)
- **Speed**: Docker can cache the exact dependency layer
- **Security**: Pin versions to avoid supply chain attacks

### Maintenance

The `requirements.lock` file should be:

- **Regenerated** when `pyproject.toml` dependencies change
- **Committed** to version control
- **Reviewed** during dependency updates
- **Updated** periodically for security patches

```bash
# Check for outdated dependencies
make check-deps

# Generate with current versions
make generate-requirements

# Upgrade to latest versions
make generate-requirements-upgrade
```

### File Structure

```txt
# requirements.lock (generated by pip-compile)
#
# This file is autogenerated by pip-compile with Python 3.13
# by the following command:
#
#    pip-compile --output-file=requirements.lock pyproject.toml
#
numpy==1.26.4
    # via
    #   delphi-polis (pyproject.toml)
    #   pandas
    #   scikit-learn
pandas==2.3.3
    # via delphi-polis (pyproject.toml)
...
```

## BuildKit Cache Mounts

### What They Do

BuildKit cache mounts preserve pip's download cache between builds:

```dockerfile
RUN --mount=type=cache,target=/root/.cache/pip \
    pip install -r requirements.lock
```

- **Cache location**: `/root/.cache/pip`
- **Persistence**: Lives outside the image, reused across builds
- **Benefit**: Downloaded wheels don't need re-fetching

### Cache Management

```bash
# View BuildKit cache size
docker system df

# Clear BuildKit cache if needed
docker builder prune

# Clear all Docker caches
docker system prune -a
```

## .dockerignore Optimizations

The `.dockerignore` file excludes unnecessary files from the Docker build context:

```
# Tests and test data
tests/
test_*.py

# Development tools
.mypy_cache/
.pytest_cache/
.ruff_cache/

# Virtual environments
delphi-dev-env/
venv/

# Documentation
docs/
*.md
!README.md

# CI/CD configs
.github/
.pre-commit-config.yaml
```

**Benefits**:

- Smaller build context (faster transfers)
- No accidental inclusion of secrets in `.env` files
- Cleaner final image

## CI/CD Integration

### GitHub Actions Example

```yaml
- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v2

- name: Build Docker image
  run: |
    DOCKER_BUILDKIT=1 docker build \
      --cache-from=type=gha \
      --cache-to=type=gha,mode=max \
      -t polis/delphi:${{ github.sha }} .
```

This uses GitHub Actions cache for BuildKit, making CI builds faster too.

## Troubleshooting

### Build Fails with "requirements.lock not found"

```bash
# Generate the lock file
make generate-requirements

# Ensure it's committed
git add requirements.lock
git commit -m "chore: add requirements.lock"
```

### Dependencies Out of Sync

If you see version conflicts between `pyproject.toml` and `requirements.lock`:

```bash
# Regenerate lock file from pyproject.toml
make generate-requirements

# Rebuild Docker image
make docker-build-no-cache
```

### Slow Builds Despite Optimization

Check if BuildKit is enabled:

```bash
# Enable BuildKit
export DOCKER_BUILDKIT=1

# Or use the Makefile (already has BuildKit enabled)
make docker-build
```

Verify cache mounts are working:

```bash
# Check BuildKit cache
docker system df -v | grep buildkit
```

### Cache Issues

If you suspect cache corruption:

```bash
# Clear BuildKit cache
docker builder prune -af

# Rebuild from scratch
make docker-build-no-cache
```

## Best Practices

### DO

- ‚úÖ Use `make docker-build` for development (fast rebuilds)
- ‚úÖ Regenerate `requirements.lock` when updating `pyproject.toml`
- ‚úÖ Commit `requirements.lock` to version control
- ‚úÖ Review dependency changes in PRs
- ‚úÖ Use `docker-build-no-cache` to verify clean builds work

### DON'T

- ‚ùå Edit `requirements.lock` manually (regenerate instead)
- ‚ùå Remove `requirements.lock` from the repository
- ‚ùå Skip regenerating lock file after dependency updates
- ‚ùå Use `--no-cache-dir` in Dockerfile builder stage (slows rebuilds)
- ‚ùå Copy source code before installing dependencies (breaks caching)

## Advanced: Custom Build Targets

You can create custom Makefile targets for specific scenarios:

```makefile
# Fast dev build (reuse all caches)
docker-build-dev:
	DOCKER_BUILDKIT=1 docker build \
		--target builder \
		-t polis/delphi:dev .

# Production build (optimized final image)
docker-build-prod:
	DOCKER_BUILDKIT=1 docker build \
		--target final \
		--no-cache \
		-t polis/delphi:prod .
```

## References

- [Docker BuildKit Documentation](https://docs.docker.com/build/buildkit/)
- [pip-compile Documentation](https://pip-tools.readthedocs.io/)
- [Multi-stage Build Best Practices](https://docs.docker.com/develop/dev-best-practices/)
- [.dockerignore Documentation](https://docs.docker.com/engine/reference/builder/#dockerignore-file)

## Summary

The optimized Docker build strategy provides:

1. **30x faster** rebuilds for code changes
2. **Reproducible** builds via lock file
3. **Persistent** cache with BuildKit mounts
4. **Smaller** build context with .dockerignore
5. **Better** developer experience

Use `make docker-build` for daily development and enjoy fast iteration cycles! üöÄ
